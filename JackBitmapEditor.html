<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Jack Bitmap Editor</title>
    <script type="text/javascript">
        var grid = new Array(0);
        var WIDTH = 48;
        var HEIGHT = 32;
        var PIXEL_SIZE = "16";
        var BINARY_BITS = 16;
		var currentColor = null;
        var currentIShift = 0;  
        var currentJShift = 0;
        var baseI;
        var baseJ;
        var drawHeight = 0;
        var includeShift = true;
        var INVERT_MODE = false;

		function pickColor(cell){
			var i = cell.id / WIDTH |0;
            var j = cell.id - i*WIDTH;
            currentColor = !grid[i][j];    
			OnCellOver(cell);            
		}
		
		function pauseEvent(e){
			if(e.stopPropagation) e.stopPropagation();
			if(e.preventDefault) e.preventDefault();
			e.cancelBubble=true;
			e.returnValue=false;
			return false;
		}
		
		function releaseColor(){
			currentColor = null;             
		}
		
        function Init() {
            grid = InitGrid();
            DisplayGrid(); 
        }

        function InitGrid() {
            var _grid = new Array(HEIGHT);
            for (i=0; i<HEIGHT; i++) {
                _grid[i] = new Array(WIDTH);
                for (j=0; j<WIDTH; j++) {
                    _grid[i][j]=false;
                }
            }
            return _grid;
        }

        /*function RotateBitmapRight() {
            var _grid = InitGrid();

            for (i=0; i<HEIGHT; i++) {
                for (j=0; j<WIDTH; j++) {
                    _grid[j][15-i]=grid[i][j];
                }
            }
            
            grid = _grid;
            DisplayGrid();
        }*/
        function InvertBitmap() {
            for (let i=0; i < HEIGHT; i++) {
                for (let j=0; j < WIDTH; j++) {
                    grid[i][j] = !grid[i][j];
                }
            }
            DisplayGrid();
        }
        function MirrorBitmap() {
            var _grid = InitGrid();

            for (i=0; i<HEIGHT; i++) {
                for (j=0; j<WIDTH; j++) {
                    _grid[i][WIDTH - 1 -j]=grid[i][j];
                }
            }

            grid = _grid;
            DisplayGrid();
        }
        function ShiftLeft() {
            currentJShift -= 1;
            for (i=0; i<HEIGHT; i++) {
                for (j=0; j<WIDTH; j++) {
                    // handle edge
                    if (j == WIDTH - 1) {
                        grid[i][j] = INVERT_MODE;
                    }
                    else {
                        grid[i][j] = grid[i][j+1];
                    }
                }
            }
            DisplayGrid();
        }
        function ShiftRight() {
            _grid = InitGrid();
            currentJShift += 1;
            for (i=0; i<HEIGHT; i++) {
                for (j=0; j<WIDTH; j++) {
                    // handle edge
                    if (j == 0) {
                        _grid[i][j] = INVERT_MODE;
                    }
                    else {
                        _grid[i][j] = grid[i][j-1];
                    }
                }
            }
            grid = _grid;
            DisplayGrid();
        }
        function ShiftUp() {
            currentIShift -= 1;
            for (i=0; i<HEIGHT; i++) {
                for (j=0; j<WIDTH; j++) {
                    // handle edge
                    if (i == HEIGHT - 1) {
                        grid[i][j] = INVERT_MODE;
                    }
                    else {
                        grid[i][j] = grid[i+1][j];
                    }
                }
            }
            DisplayGrid();
        }
        function ShiftDown() {
            _grid = InitGrid();
            currentIShift += 1;
            for (i=0; i<HEIGHT; i++) {
                for (j=0; j<WIDTH; j++) {
                    // handle edge
                    if (i == 0) {
                        _grid[i][j] = INVERT_MODE;
                    }
                    else {
                        _grid[i][j] = grid[i-1][j];
                    }
                }
            }
            grid = _grid;
            DisplayGrid();
        }
        
        function DisplayGrid() {
            var str = "<table border=1 cellspacing=0>";
            var i,j, backgroundColor;
            let font_style = "style='font-size:" + PIXEL_SIZE + "px' ";
            for (i=-1; i<HEIGHT; i++) {
                str=str+"<tr>";
                for (j=-1; j<WIDTH; j++) {
                    if (i == -1 && j != -1) {
                        str=str+"<td " + font_style +">" + (j+1) + "</td>";
                    } else if (i != -1 && j == -1) {
                        str=str+"<td "+ font_style +">" + (i+1) + "</td>";
                    } else if (i ==-1 && j == -1) {
                        str=str+"<td/>";
                    } else {

                        if (grid[i][j] == true)
                            backgroundColor = "black";
                        else
                            backgroundColor = "white";
                        str=str+"<td onmousedown=\"pickColor(this); pauseEvent(event);\" onmouseup=\"releaseColor(this); pauseEvent(event);\" onmouseover=\"OnCellOver(this)\" id="; str=str+(i*WIDTH+j); str=str+" width=" + PIXEL_SIZE + " height=" + PIXEL_SIZE + " bgcolor=" + backgroundColor + "></td>";
                    }                                        
                }
                str=str+"</tr>";
            }
            str=str+"</table>"

            gridElement = document.getElementById('grid');
            gridElement.innerHTML = str;
            GenerateBitMap();
        }

        function OnCellOver(cell) {
			if(currentColor==null){
				return;
			}
            var i = cell.id / WIDTH |0;
            var j = cell.id - i*WIDTH;
            grid[i][j] = currentColor;
            if (grid[i][j])
                cell.style.backgroundColor = "black";
            else
                cell.style.backgroundColor = "white";
            GenerateBitMap();
        }
        function GetColumns(leftJ, rightJ, baseJ) {
            let leftmost = Math.min(0, -(Math.ceil( (baseJ - leftJ)/16) ));
            let rightmost = Math.max(0, -(Math.ceil( (baseJ - rightJ)/16 )));
            let columns = []
            for (let i = leftmost; i < rightmost + 1; i++) {
                columns.push(i);
            }
            return columns.sort((a, b) => a - b);
        }
        function GetUsedWords() {
            // returns an object of {..., -1:[[i, j], [i2, j], [i3, j]...], 0:[i, j2], 1:[i, j3], ...} for which (i,j), (i, j+1), (i, j+2), ... (i,j+15) are the coordinates of a word that is to be included in the 
            // code for the bitmap and the keys (..., -1, 0, 1, ...) are the columns that the words are in
            let words = {};
            let this_col;

            let leftJ = 0;
            let rightJ = WIDTH - 1;
            baseJ = 0;

            let bottomI = HEIGHT - 1;
            let topI = 0;
            baseI = HEIGHT - 1;
            

            // find drawing borders, unless the user wants the whole canvas to be included in the bitmap
            if (!document.getElementById("fullCanvas".checked)) {
                let breaker = false;
                for  (let j = 0; j < WIDTH; j++) {
                    if (breaker) break;
                    for (let i = HEIGHT - 1; i >= 0; i--) {
                        if (grid[i][j] != INVERT_MODE) {
                            leftJ = j;
                            breaker = true;
                            break;
                        }
                    }
                }
                breaker = false;
                for  (let j = WIDTH - 1; j >= 0; j--) {
                    if (breaker) break;
                    for (let i = HEIGHT - 1; i >= 0; i--) {
                        if (grid[i][j] != INVERT_MODE) {
                            rightJ = j;
                            breaker = true;
                            break;
                        }
                    }
                }
                breaker = false;
                for (let i = HEIGHT - 1; i >= 0; i--) {
                    if (breaker) break;
                    for (let j = 0; j < WIDTH; j++) {
                        if (grid[i][j] != INVERT_MODE) {
                            bottomI = i;
                            breaker = true;
                            break;
                        }
                    }
                }
                breaker = false;
                for (let i = 0; i < HEIGHT; i++) {
                    if (breaker) break;
                    for (let j = 0; j < WIDTH; j++) {
                        if (grid[i][j] != INVERT_MODE) {
                            topI = i;
                            breaker = true;
                            break;
                        }
                    }
                } 
                if (includeShift) {
                    // adjust base for shifting
                    baseJ = leftJ - currentJShift;
                    baseI = bottomI - currentIShift;
                }
                else {
                    baseJ = leftJ
                    baseI = bottomI;
                } 
            }

            let columns = GetColumns(leftJ, rightJ, baseJ);
            for (const col of columns) {
                this_col = [];
                col_index = col * 16 + baseJ
                // Find all the words in this column that are used
                
                // if fullCanvas, then use all the words from i=0 to i=HEIGHT-1
                if (document.getElementById("fullCanvas").checked) {
                    for (i=0; i < HEIGHT; i++) {
                        this_col.push([i, col_index]);
                    }
                }
                // if rectangular, use i=topI to i=bottomI for each column
                else if (document.getElementById("enforceRectangular").checked) {
                    //maxI = Math.max(bottomI, baseI);
                    //minI = Math.min(topI, baseI);
                    for (i=Math.min(topI, baseI), maxI=Math.max(bottomI, baseI); i <= maxI; i++) {
                        if (i<0 || i>= HEIGHT) continue;  // ignore rows that are off the canvas and are outside of the contract
                        this_col.push([i, col_index]);
                    }

                }
                // if fit to drawing, for each column, find the i values that have stuff included and include currentIshift words of padding (if necessary) to each words
                else {  // fit to drawing
                    let includedIvalues = new Set();
                    for (i=Math.min(topI, baseI), maxI=Math.max(bottomI, baseI); i <= maxI; i++) {
                        this_i_in = false;
                        if (i<0 || i>= HEIGHT) continue;  // ignore rows that are off the canvas and are outside of the contract
                        for (j=col_index; j < col_index + 16; j++) {
                            if (j>=0 && j < WIDTH) {
                                
                                if (grid[i][j] != INVERT_MODE) {
                                    this_i_in = true;
                                    break;
                                }
                            }
                            
                        }
                        if (this_i_in) {
                            
                            includedIvalues.add(i);
                            // add the buffer region the number of rows as abs(currentIShift) in the direction of currentIShift
                            for (m=Math.min(i, i - currentIShift), n=Math.max(i, i - currentIShift); m <= n; m++) {
                                if (m<0 || m>= HEIGHT) continue;  // ignore rows that are off the canvas and are outside of the contract
                                includedIvalues.add(m);
                            }
                        }
                    }
                    for (let item of includedIvalues) {
                        this_col.push([item, col_index]);
                    }
                }
                words[col.toString()] = this_col;
            }
            // set drawHeight for the use of other functions
            drawHeight = Math.max(bottomI, baseI) - Math.min(topI, baseI);
            return words;


        }
        function GenerateBitMap() {
            if (document.getElementById("pauseCode").checked) return;
            let i, j;
            let value;
  
            let methodType = "function";
            let functionName = "draw";

            generateCode = document.getElementById('generatedCode');
            generateCode.value =    methodType + " void " +
                                    functionName +
                                    "(int location) {\n\tvar int memAddress; \n\tlet memAddress = 16384+location;\n";

            colsOfWords = GetUsedWords()
            let baseRow = 0;
            if (document.getElementById("baseTopLeft").checked) {
                console.log(drawHeight)
                baseRow = drawHeight;
            }
            for (let col in colsOfWords) {
                if (document.getElementById("commentsOn").checked) {
                    generateCode.value = generateCode.value + "\t// column " + col + "\n";
                }
                for (coordinates of colsOfWords[col]) {
                    let value = GetWordValue(coordinates[0], coordinates[1]);
                    generateCode.value = generateCode.value + GenerateCodeLine(coordinates[0] - baseI + baseRow, value, parseInt(col));
                }
                
            }
            generateCode.value = generateCode.value + "\treturn;\n}";
        }
        function GetWordValue(i, j) {
            // given the coordinates i, j of the start of a 16 pixel series corresponding with a 16-bit integer in RAM, returns the base_10 
            // value that must be stored in the RAM. Interprets pixels that are off the canvas to false

            let binary = "";
            for (m=j, n=j+BINARY_BITS; m<n; m++) {
                // see if the pixel is on the canvas. contract: no words are ever included that are entirely off canvas, so we only need to check m (j) values
                if (m<0 || m >= WIDTH) {
                    // off canvas pixels
                    if (INVERT_MODE) binary = "1" + binary;
                    else binary = "0" + binary;
                }
                else {
                    if (grid[i][m])
                        binary = "1" + binary;
                    else
                        binary = "0" + binary;
                }
            }
            isNegative = false;
            //if number is negative, get its  one's complement
            if (binary[0] == "1") {
                isNegative = true;
                oneComplement = "";
                for (k=0; k<BINARY_BITS; k++) { /////
                    if (binary[k] == "1")
                        oneComplement = oneComplement + "0";
                    else
                        oneComplement = oneComplement + "1";
                }
                binary = oneComplement;                 
            }
            
            //calculate one's complement decimal value
            let value = 0;
            for (k=0; k<BINARY_BITS; k++) { ////
                value = value * 2;
                if (binary[k] == "1")
                    value=value+1;
            }                

            //two's complement value if it is a negative value
            if (isNegative == true)
                value = -(value + 1);
        
            return value;
        }

        function GenerateCodeLine(row, value, col) {
            let mem_shift = row * 32 + col;
            if (mem_shift > 0) mem_shift = " +" + mem_shift;
            else if (mem_shift == 0) mem_shift = "";
            else mem_shift = " " + mem_shift;
            if (value == -32768){ 
                
                str = "\tdo Memory.poke(memAddress" + mem_shift + ", ~32767);\n"; 
            } else {
                str = "\tdo Memory.poke(memAddress" + mem_shift + ", " + value + ");\n";
            }
                return str;
        }

        function ResetShift() {
            currentIShift = 0;
            currentJShift = 0;
            GenerateBitMap();
        }
        function ToggleInvertMode() {
            if (document.getElementById("invertMode").checked) {
                INVERT_MODE = true;
                GenerateBitMap();
            }
            else {
                INVERT_MODE = false;
                GenerateBitMap();
            }
        }
        function isInteger(value) {
            return /^\d+$/.test(value);
         }
        function ResetSize() {
            // resets the canvas width, height, and pixel size to the values specified by input fields as long as both fields contain integer values
            newWidth = document.getElementById("inputWidth").value;
            newHeight  = document.getElementById("inputHeight").value;
            newPxSize = document.getElementById("pixelSize").value;
            if (isInteger(newWidth) && isInteger(newHeight) && isInteger(newPxSize)) {
                // set the new measurements, ensuring that width is a multiple of 16 (for the sake of fullCanvas mode)
                WIDTH = Math.floor(parseInt(newWidth)/16) * 16;
                HEIGHT = parseInt(newHeight);
                PIXEL_SIZE = parseInt(newPxSize);
                Init();
            }
        }
    </script>
</head>
<body onload="Init();">
    <h4><i>Idea and first code by Golan Parashi, updated by Ignacio del Valle Alles, and extended by Erik Umble </i></h4>
    <h1>Jack Bitmap Editor</h1>
    <p>This is a simple bitmap editor, with a special emphasis on making animation frames easier. Simply draw and the Jack code to produce the drawing will be displayed
        on the right. Note that if your drawing does not fill the canvas, the code will only be generated for the part that your drawing takes up with 'location' in the 
        code referring to the top left corner of the drawing (this can be changed to refer to the bottom left with the radio button below). 
    </p>
    <p>
        Note that you can create sequencial frames of an animation by using the shift buttons (a buffer is created in the code such that
         calling a function that refers to the next animation frame will automatically erase the area that the sprite has moved out of).
         Also note that you can enter Inverted mode for drawing with white on a black canvas for night/dark themed games 
         (this mode expects the background to be black, erases by making pixels black, and interprets the drawing as the white pixels on the canvas).
    </p>
    <p>
        If you would rather work on a different sized canvas, simply change the height and width fields and click reload. Note that for very large canvas sizes,
         you might need to change the canvas pixel size to a smaller value. Also note that width must be a multiple of 16. 'Comments On' referes to the comments in the 
         Jack code that specify the column of the drawing that the following code is for (column 1 is to the right of column 0, which is to the right of column -1 and so on).
          If your device is running slow on automatic code generation, you can use 
         'Pause Code Generation', draw, then unselect the field when you are ready to get the code. For more details, see <a href="">demo</a>.
    </p>
    
    <p>
    <table>
        <thead>
            <tr>
                <th align="left">Bitmap</th>
                <th align="left">Generated Jack Code</th>
            </tr>
        </thead>
        <tr>
            <td><div id="grid"/></td>
            <td><textarea id="generatedCode" cols="50" rows="48" readonly="read-only"></textarea></td>                                
        </tr>
        <tr>
            <table>
                <tr>
                    <td align="center"><input type="button" value="Shift left <" onclick="ShiftLeft()"/></td>
                    <td align="center"><input type="button" value="Shift right >" onclick="ShiftRight()"/></td>
                    <td align="center"><input type="button" value="Shift up ^" onclick="ShiftUp()"/></td>
                    <td align="center"><input type="button" value="Shift down v" onclick="ShiftDown()"/></td>
                    <td align="center"><input type="button" value="Clear Shifting" onclick="ResetShift()"/></td>
                    <td>&nbsp</td>
                    <td align="center"><input type="button" value="Flip horizontally" onclick="MirrorBitmap()"/></td>
                    <td align="center"><input type="button" value="Invert" onclick="InvertBitmap()"/></td>
                    <td align="center"><input id="invertMode" onclick="ToggleInvertMode()" type="checkbox"/><label for="invertMode">Inverted Mode</label></td>
                    <td>&nbsp</td>
                    <td align="center"><input id="pauseCode" onclick="GenerateBitMap()" type="checkbox"/><label for="pauseCode">Pause Code Generation</label></td>
                    <td align="center"><input checked id="commentsOn" onclick="GenerateBitMap()" type="checkbox"/><label for="commentsOn">Comments On</label></td>
                </tr>
            </table>
        </tr>
        <tr>
            <table>
                <tr>
                    <td>
                        <form action="javascript:ResetSize()">
                            Canvase Size: 
                            <input id="inputWidth" placeholder="width" maxlength="4" size="4" type="text" value="48">
                            x
                            <input id="inputHeight" placeholder="height" maxlength="4" size="4" type="text" value="32">
                            <button>Reload</button>
                            Canvas pixel size: 
                            <input id="pixelSize" placeholder="px" maxlength="2" size="1" type="text" value="16">
                        </form>
                    </td>
                </tr>
            </table>
        </tr>
        <tr>
            <table>
                <tr>
                    <td align="center">
                        <input checked id="fitToDrawing" name="marginType" onclick="GenerateBitMap()" type="radio"/>
                        <label for="fitToDrawing">Fit to drawing</label>

                        <input id="enforceRectangular" name="marginType" onclick="GenerateBitMap()" type="radio"/>
                        <label for="enforceRectangular">Rectangular</label>

                        <input id="fullCanvas" name="marginType" onclick="GenerateBitMap()" type="radio"/>
                        <label for="fullCanvas">Full Canvas</label>
                    </td>
                </tr>
            </table>
        </tr>
        <tr>
            <table>
                <tr>
                    <td align="center">
                        Base address:
                        <input checked id="baseTopLeft" name="baseRowFrom" onclick="GenerateBitMap()" type="radio"/>
                        <label for="baseTopLeft">Top Left</label>

                        <input id="baseBottomLeft" name="baseRowFrom" onclick="GenerateBitMap()" type="radio"/>
                        <label for="baseBottomLeft">Bottom Left</label>
                    </td>
                </tr>
            </table>
        </tr>
    </table>
</body>
</html>